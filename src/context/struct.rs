/*
* This file is part of the cloneable_errors library, licensed under the MIT license:
* https://github.com/mini-bomba/cloneable_errors
*
* Copyright (C) 2024-2025 mini_bomba
*/

use std::{
    error::Error,
    fmt::{Debug, Display},
    sync::Arc,
};
#[cfg(feature = "extensions")]
use std:: {
    any::TypeId,
    collections::HashMap,
};

#[cfg(feature = "extensions")]
use crate::extensions::{Extension, ExtensionMap};
use crate::util::option_ptr_eq;
use crate::IntoErrorIterator;
use crate::SharedString;

#[derive(Clone)]
#[non_exhaustive]
/// An annotated error stack
pub struct ErrorContext {
    pub context: SharedString,
    pub cause: Option<Arc<dyn Error + Send + Sync + 'static>>,
    #[cfg(feature = "extensions")]
    pub extensions: Option<ExtensionMap>,
}

impl ErrorContext {
    /// Creates a new `ErrorContext` with the given initial error message.
    ///
    /// The error message should either be a `&'static str`, or an `Arc<str>`.
    /// `String` is also accepted, but will be converted to an `Arc<str>`.
    #[must_use]
    pub fn new<T>(msg: T) -> ErrorContext
    where
        T: Into<SharedString>,
    {
        ErrorContext {
            context: msg.into(),
            cause: None,
            #[cfg(feature = "extensions")]
            extensions: None,
        }
    }
}

#[cfg(feature = "extensions")]
impl ErrorContext {
    /// Adds an extension to the error.
    ///
    /// Only one instance of any extension can be attached to an error at a time - adding another
    /// instance of an existing extension type overwrites the previous entry.
    ///
    /// This is a convienience version of [`ErrorContext::add_extension`] made for chaining calls.
    #[must_use]
    pub fn with_extension(mut self, ext: Arc<dyn Extension>) -> Self {
        self.add_extension(ext);
        self
    }

    /// Adds an extension to the error.
    ///
    /// Only one instance of any extension can be attached to an error at a time - adding another
    /// instance of an existing extension type overwrites the previous entry.
    pub fn add_extension(&mut self, ext: Arc<dyn Extension>) {
        use std::ops::Deref;

        match self.extensions {
            None => {
                let mut extensions = HashMap::with_capacity(1);
                extensions.insert(ext.deref().type_id(), ext);
                self.extensions = Some(Arc::from(extensions));
            }
            Some(ref mut extensions) => {
                let extensions = Arc::make_mut(extensions);
                extensions.insert(ext.deref().type_id(), ext);
            }
        }
    }

    /// Removes an extension of a given type from the error, if it exists.
    ///
    /// This is a convienience version of [`ErrorContext::remove_extension`] made for chaining
    /// calls. If you need the value of the removed extension, use that function instead.
    #[must_use]
    pub fn without_extension<E: Extension>(mut self) -> Self {
        self.remove_extension::<E>();
        self
    }

    /// Removes an extension of a given type from the error, if it exists, returning the removed
    /// extension.
    #[allow(clippy::missing_panics_doc)] // the only panic path would be a bug
    pub fn remove_extension<E: Extension>(&mut self) -> Option<Arc<E>> {
        let extensions = self.extensions.as_mut().map(Arc::make_mut)?;
        extensions
            .remove(&TypeId::of::<E>())
            .map(|ext| Arc::downcast(ext).expect("BUG: Extension stored under the wrong TypeId!"))
    }

    /// Retrieves an extension of a given type, if it exists.
    #[must_use]
    #[allow(clippy::missing_panics_doc)] // the only panic path would be a bug
    pub fn get_extension<E: Extension>(&self) -> Option<Arc<E>> {
        self.extensions
            .as_ref()?
            .get(&TypeId::of::<E>())
            .cloned()
            .map(|ext| Arc::downcast(ext).expect("BUG: Extension stored under the wrong TypeId!"))
    }
}

impl Display for ErrorContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.context)
    }
}

impl Debug for ErrorContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut iter = self.error_chain();
        write!(f, "{}", iter.next().expect("first item should exist"))?;

        let mut iter = iter.enumerate();
        if let Some((i, item)) = iter.next() {
            write!(f, "\n\nCaused by:\n    {i}: {item}")?;

            for (i, item) in iter {
                write!(f, "\n    {i}: {item}")?;
            }
        }

        Ok(())
    }
}

/// `ErrorContext` values are compared using pointer equality.
///
/// In practice this means that two instances of the same error generated by separate function
/// calls will not be equal, but two clones of the same error will be equal.
///
/// Errors without a cause and extensions, created using `&'static str` are an exception to this.
impl PartialEq for ErrorContext {
    fn eq(&self, other: &Self) -> bool {
        let mut result = true;
        result &= self.context == other.context;
        result &= option_ptr_eq(&self.cause, &other.cause);
        #[cfg(feature = "extensions")]
        {
            result &= option_ptr_eq(&self.extensions, &other.extensions);
        }
        result
    }
}
impl Eq for ErrorContext {}

impl Error for ErrorContext {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        if let Some(cause) = self.cause.as_deref() {
            Some(cause)
        } else {
            None
        }
    }
}
