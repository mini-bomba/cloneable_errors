/* 
* This file is part of the cloneable_errors library, licensed under the MIT license: 
* https://github.com/mini-bomba/cloneable_errors
*
* Copyright (C) 2024 mini_bomba
*/

use std::{convert::Infallible, error::Error, fmt::{Debug, Display}, sync::Arc};

use crate::IntoErrorIterator;
use crate::SharedString;

// The ErrorContext struct

#[derive(Clone)]
#[non_exhaustive]
/// An annotated error stack
pub struct ErrorContext {
    pub context: SharedString,
    pub cause: Option<Arc<dyn Error + Send + Sync + 'static>>,
}

impl ErrorContext {
    pub fn new<T>(msg: T) -> ErrorContext
    where T: Into<SharedString>
    {
        ErrorContext { context: msg.into(), cause: None }
    }
}

impl Display for ErrorContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.context)
    }
}

impl Debug for ErrorContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut iter = self.error_chain();
        write!(f, "{}", iter.next().expect("first item should exist"))?;

        let mut iter = iter.enumerate();
        if let Some((i, item)) = iter.next() {
            write!(f, "\n\nCaused by:\n    {i}: {item}")?;

            for (i, item) in iter {
                write!(f, "\n    {i}: {item}")?;
            }
        }

        Ok(())

    }
}

/// `ErrorContext` values are compared using pointer equality.
///
/// In practice this means that two instances of the same error generated by separate function
/// calls will not be equal, but two clones of the same error will be equal.
///
/// Errors without a cause, created using `&'static str` are an exception to this.
impl PartialEq for ErrorContext {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self { context: self_ctx, cause: None             }, Self { context: other_ctx, cause: None             }) 
                => self_ctx == other_ctx,
            (Self { context: self_ctx, cause: Some(self_cause) }, Self { context: other_ctx, cause: Some(other_cause) }) 
                => self_ctx == other_ctx && Arc::ptr_eq(self_cause, other_cause),
            // different cause values
            _ => false
        }
    }
}
impl Eq for ErrorContext {}

impl Error for ErrorContext {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        if let Some(cause) = self.cause.as_deref() {
            Some(cause)
        } else {
            None
        }
    }
}

#[cfg(feature = "anyhow")]
impl From<anyhow::Error> for ErrorContext {
    /// <div class="warning">
    ///
    /// NOTE: Converting [`anyhow::Error`] into [`ErrorContext`] causes the anyhow error stack to
    ///       be flattened into a stack of string errors! Extracting the error type-specific data
    ///       that is not exposed in the [`Display`] impl will not be possible! 
    ///
    /// </div>
    fn from(value: anyhow::Error) -> Self {
        let flattened = crate::SerializableError::from_anyhow(&value);
        ErrorContext { 
            context: flattened.context,
            cause: flattened.cause.map(|arc| arc as Arc<(dyn Error + Send + Sync + 'static)>),
        }
    }
}


// .context() traits
// on all Errors

/// A helper trait for annotating any Error with an [`ErrorContext`]
pub trait ErrContext {
    /// Wrap this error into a new [`ErrorContext`] error, annotated with the specified context
    fn context<M>(self, msg: M) -> ErrorContext
    where M: Into<SharedString>;
}

impl<T> ErrContext for T
where T: Error + Send + Sync + 'static
{
    fn context<M>(self, msg: M) -> ErrorContext
    where M: Into<SharedString>
    {
        ErrorContext {
            context: msg.into(),
            cause: Some(Arc::new(self)),
        }
    }
}

// on anyhow::Error

#[cfg(feature = "anyhow")]
/// A helper trait for converting an anyhow error stack into an [`ErrorContext`] stack
pub trait AnyhowErrContext {
    /// Convert this anyhow error into a new [`ErrorContext`] error, annotated with the specified context message
    ///
    /// Note: This function will flatten the entire error stack into a [`crate::SerializableError`], any data not
    ///       exposed in the Display implementations of errors will be lost!
    fn context<M>(self, msg: M) -> ErrorContext
    where M: Into<SharedString>;
}

#[cfg(feature = "anyhow")]
impl AnyhowErrContext for anyhow::Error {
    fn context<M>(self, msg: M) -> ErrorContext
    where M: Into<SharedString> 
    {
        ErrorContext { 
            context: msg.into(),
            cause: Some(Arc::new(ErrorContext::from(self)))
        }    
    }
}

// on all Result<>s

#[allow(clippy::missing_errors_doc)]
/// A helper trait for annotating result errors and empty options
pub trait ResContext<T, E> {
    /// Map the error into a new cloneable [`ErrorContext`] error, annotated with a specified context message
    fn context<M>(self, msg: M) -> Result<T, ErrorContext>
    where M: Into<SharedString>;

    /// Map the error into a new cloneable [`ErrorContext`] error, annotated with a dynamically computed context
    /// message
    fn with_context<M, F>(self, f: F) -> Result<T, ErrorContext>
    where M: Into<SharedString>,
          F: FnOnce() -> M;
}

impl<T, E> ResContext<T, E> for Result<T, E>
where E: ErrContext
{
    fn context<M>(self, msg: M) -> Result<T, ErrorContext>
    where M: Into<SharedString>
    {
        self.map_err(|e| e.context(msg))
    }

    fn with_context<M, F>(self, f: F) -> Result<T, ErrorContext>
    where M: Into<SharedString>,
          F: FnOnce() -> M 
    {
        self.map_err(|e| e.context(f()))
    }
}

// on Result<>s with anyhow::Error
#[cfg(feature = "anyhow")]
#[allow(clippy::missing_errors_doc)]
/// A helper trait for converting anyhow results into [`ErrorContext`] results
pub trait AnyhowResContext<T, E> {
    /// Map the anyhow error into a new [`ErrorContext`] error, annotated with the specified context message
    ///
    /// Note: This function will flatten the entire error stack into a [`crate::SerializableError`], any data not
    ///       exposed in the Display implementations of errors will be lost!
    ///       (this only applies if the result error is an anyhow error)
    fn context<M>(self, msg: M) -> Result<T, ErrorContext>
    where M: Into<SharedString>;

    /// Map the anyhow error into a new [`ErrorContext`] error, annotated with a dynamically
    /// computed context message
    ///
    /// Note: This function will flatten the entire error stack into a [`crate::SerializableError`], any data not
    ///       exposed in the Display implementations of errors will be lost!
    ///       (this only applies if the result error is an anyhow error)
    fn with_context<M, F>(self, f: F) -> Result<T, ErrorContext>
    where M: Into<SharedString>,
          F: FnOnce() -> M;
}

#[cfg(feature = "anyhow")]
impl<T, E> AnyhowResContext<T, E> for Result<T, E>
where E: AnyhowErrContext
{
    fn context<M>(self, msg: M) -> Result<T, ErrorContext>
    where M: Into<SharedString>
    {
        self.map_err(|e| e.context(msg))
    }

    fn with_context<M, F>(self, f: F) -> Result<T, ErrorContext>
    where M: Into<SharedString>,
          F: FnOnce() -> M 
    {
        self.map_err(|e| e.context(f()))
    }
}

// on all Option<>s

impl<T> ResContext<T, Infallible> for Option<T>
{
    fn context<M>(self, msg: M) -> Result<T, ErrorContext>
    where M: Into<SharedString>
    {
        self.ok_or_else(|| ErrorContext { context: msg.into(), cause: None })
    }

    fn with_context<M, F>(self, f: F) -> Result<T, ErrorContext>
    where M: Into<SharedString>,
          F: FnOnce() -> M 
    {
        self.ok_or_else(|| ErrorContext { context: f().into(), cause: None })
    }
}
